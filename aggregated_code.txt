# File: ../Extraction/create.sh
# --------------------------------------------------
#!/bin/bash

# Description: This script is used to execute the terraform plan and apply the changes to the AWS account.
# Usage: ./execute.sh

# Step 0: Update root outputs.tf file by ruuning script
#run update_root_outputs_tf.py
# exit when the script fails

echo "Updating root outputs.tf file..."
python3 update_root_outputs_tf.py
if [ $? -ne 0 ]; then
    echo "Failed to update root outputs.tf file."
    exit 1
fi
# Path to your tfvars file
tfvars_file="./terraform/secrets.tfvars"

# Extract the value of secrets_manager_secret_name from the file
secret_name=$(grep '^secrets_manager_secret_name' "$tfvars_file" | sed -n 's/.*"\(.*\)".*/\1/p')

# Step 1: Check if the secret exists in the AWS Secrets Manager service and get the secret arn
secret_arn=$(aws secretsmanager list-secrets --filter Key="name",Values="$secret_name" --query "SecretList[0].ARN" --output text)
echo $secret_arn

# Step 2: Check if the secret does not exist, then create the secret
if [[ -z "$secret_arn" || "$secret_arn" == "None" ]]; then
    secret_arn=$(aws secretsmanager create-secret --name "$secret_name" --description "Secret for Spotify project1" --query 'ARN' --output text)
    echo "Secret created with ARN: $secret_arn"
else
    echo "Secret already exists with ARN: $secret_arn"
fi

# Step 3: Change to the terraform directory and initialize the terraform
cd terraform
terraform init

terraform plan -out=tfplan -var-file=secrets.tfvars

# Step 5: Prompt the user to confirm the plan
read -p "Do you want to apply the plan? (y/n): " confirm
if [ "$confirm" != "y" ]; then
    exit 0
fi

# Step 6: Set the log level to debug, create the logs directory and set the log path
export TF_LOG=DEBUG
mkdir -p ./logs
export TF_LOG_PATH=./logs/terraform_debug.log

# Step 7: Apply the plan
terraform apply tfplan

# File: ../Extraction/destroy.sh
# --------------------------------------------------
cd terraform
# list all resources
terraform state list
read -p "Remove secret resource? (y/n): " confirm
if [ "$confirm" == "y" ]; then
terraform state rm module.secretsmanager.aws_secretsmanager_secret.spotify_secret
fi

read -p "Remove random_id resource? (y/n): " confirm
if [ "$confirm" == "y" ]; then
terraform state rm random_integer.random_id
fi

read -p "destroy all resources? (y/n): " confirm
if [ "$confirm" == "y" ]; then
terraform destroy -var-file=./terraform.tfvars
fi

# File: ../Extraction/README.md
# --------------------------------------------------
# My Protfolio Web Application with Terraform

This project demonstrates a two‑page AWS web application. It consists of a static landing page and an interactive data visualization page that fetches dynamic data from an AWS Lambda function via API Gateway. The entire infrastructure is provisioned using Terraform, ensuring a repeatable, manageable, and scalable deployment process.

## Technologies Used
- **AWS Services:**  
  - Amazon S3 for static website hosting
  - Amazon CloudFront for content delivery
  - Amazon API Gateway for creating RESTful APIs
  - AWS Lambda for serverless compute
  - Amazon Route 53 for DNS management
- **Infrastructure as Code:**
  - Terraform for provisioning and managing AWS resources
- **Programming Languages:**
  - Python for AWS Lambda function code
  - HTML, CSS for the web application
  - JavaScript for the interactive page
- **Development Tools:**
  - Visual Studio Code for development
  - Git for version control
- **Deployment Tools:**
  - AWS CLI for managing AWS resources
  - Terraform CLI for provisioning infrastructure
- **Version Control:**
  - Git for source code management
- **Package Management:**
  - Python's `pip` for managing Lambda function dependencies
  - Node.js and npm for managing JavaScript dependencies
- **Testing and Debugging:**
  - Visual Studio Code for local development and debugging
  - AWS CloudWatch for monitoring and logging Lambda function execution

## Website Architecture Overview
- **Landing Page: Static Website:**  
  A static landing page hosted on Amazon S3. It is served via Amazon CloudFront, and the domain is managed using Amazon Route 53. The static page includes HTML, CSS, and images.
  It is publicly accessible and serves as the entry point for users.

- **Visualization Project Page: Interactive Visualization:**  
  A single-page application (SPA) that fetches dynamic data from an AWS Lambda function. The SPA is hosted on Amazon S3 and served via Amazon CloudFront. It uses JavaScript to make API calls to the backend and render visualizations based on the fetched data. 
  A Lambda function runs every night at 3:00AM, and processes data from S3 and returns it to S3 in a desired format. 
  The SPA is hosted on Amazon S3 and served via Amazon CloudFront. It uses JavaScript to make API calls to the backend and render visualizations based on the fetched data.

## Directory Structure
The project is organized into several directories, each serving a specific purpose. Below is a high-level overview of the directory structure:
```plaintext
JumpReact/
├── terraform/              # Terraform configurations for AWS resources
│   ├── backend.tf          # Remote backend configuration for Terraform state
│   ├── data.tf             # Data source definitions
│   ├── locals.tf           # Local values used in Terraform
│   ├── main.tf             # Primary Terraform configuration
│   ├── outputs.tf          # Outputs to expose resource information
│   ├── providers.tf        # Provider configurations (AWS)
│   ├── terraform.tfvars    # Variable values for default environment
│   ├── variables.tf        # Variable definitions
│   |
│   ├── modules/            # Reusable modules for Terraform resources
│   │   ├── api_gateway/    # API Gateway module
│   │   │   ├── main.tf
│   │   │   ├── variables.tf
│   │   │   └── outputs.tf
│   │   │
│   │   ├── cloudfront/     # CloudFront distribution module
│   │   │   ├── main.tf
│   │   │   ├── variables.tf
│   │   │   └── outputs.tf
│   │   │
│   │   ├── iam/            # IAM roles and policies module
│   │   │   ├── main.tf
│   │   │   ├── variables.tf
│   │   │   └── outputs.tf
│   │   │
│   │   ├── lambda/         # Lambda function module
│   │   │   ├── main.tf
│   │   │   ├── variables.tf
│   │   │   └── outputs.tf
│   │   │
│   │   ├── route53/        # Route 53 DNS module
│   │   │   ├── main.tf
│   │   │   ├── variables.tf
│   │   │   └── outputs.tf
│   │   │
│   │   └── s3/             # S3 bucket module
│   │       ├── main.tf
│   │       ├── variables.tf
│   │       └── outputs.tf
│   │
│   └── environments/       # Environment-specific configurations (optional)
│       ├── example/       # Example environment configurations
│       │   ├── main.tf
│       │   ├── variables.tf
│       │   ├── backend.tf
│       │
│       └── prod/           # Production environment-specific configurations
│           ├── main.tf
│           ├── variables.tf
│           ├── backend.tf
│           └── terraform.tfvars
│
├── app/                # Application assets
│   ├── static/         # Static assets for the landing page
│   │   ├── index.html
│   │   ├── styles.css
│   │   └── images/
│   │       ├── logo1.png
│   │       ├── logo2.png
│   │       ├── logo3.png
│   │       └── photo.png
│   │
│   └── interactive/    # Interactive visualization page assets
│       ├── interactive.html
│       ├── styles.css
│       └── scripts/
│           └── main.js
│
├── lambda/             # AWS Lambda function code and dependencies
│   ├── lambda_function.py
│   └── requirements.txt
│
├── .vscode/            # VS Code workspace settings and launch configurations
│   ├── settings.json
│   ├── tasks.json
│   └── launch.json
│
├── .gitignore          # Git ignore file
└── README.md           # Project documentation
```

## Web Application Structure
- **Static Page:**  
  Located in `app/static/`, this folder contains the landing page (HTML, CSS, images) served publicly.
- **Interactive Page:**  
  Located in `app/interactive/`, this folder contains the interactive visualization page (HTML, CSS, JavaScript). It fetches data from the AWS Lambda function via API Gateway. The JavaScript code handles API calls and data rendering.
- **Assets:**
  The `app/static/` folder contains static assets such as images and stylesheets used in the landing page. The `app/interactive/` folder contains the interactive page's HTML, CSS, and JavaScript files. The JavaScript code handles API calls and data rendering.

- **Lambda Function:**
  The `lambda/` folder contains the AWS Lambda function code and its dependencies. The Lambda function is responsible for processing of dynamic data. It is a scheduled function that runs daily and fetches data from an external API. The function is triggered by an API Gateway endpoint, which allows the interactive page to make HTTP requests to it. The Lambda function is written in Python and uses the `requests` library to make HTTP requests to the external API. The function processes the data and returns it in a format suitable for the interactive page.

## Setup Instructions
1. **Clone the Repository:**
   ```bash
    git clone git clone https://github.com/jayadeyemi/JumpReact.git
    cd JumpReact
    ```
2. **Install Dependencies:**
    - For the Lambda function, navigate to the `lambda/` directory and install dependencies:
      ```bash
      cd lambda
      pip install -r requirements.txt -t .
      ```
    - For the interactive page, navigate to the `app/interactive/` directory and install any necessary JavaScript dependencies (if applicable).
      ```bash
      cd app/interactive
      npm install
      ```
3. **Configure AWS Credentials:**
    - Ensure your AWS credentials are set up. You can configure them using the AWS CLI:
      ```bash
      aws configure
      ```
    - Alternatively, set environment variables for `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, and `AWS_REGION`.   
3. **Local Development:**
   - Modify your application assets in the `app/` folder.
   - Update your Lambda function code in the `lambda/` folder as needed.
   - Test changes locally before deploying

2. **Terraform Setup:**
   - Ensure you have [Terraform](https://www.terraform.io/downloads.html) installed.
   - Navigate to the `terraform/` directory:
     ```bash
     cd terraform
     terraform init
     ```
   - Review the planned changes:
     ```bash
     terraform plan -out tfplan -var-file=./terraform/environments/prod/terraform.tfvars
     ```
   - Apply the configuration:
     ```bash
     terraform apply tfplan
     ```

3. **Local Development:**
   - Modify your application assets in the `app/` folder.
   - Update your Lambda function code in the `lambda/` folder as needed.
   - Test changes locally before deploying.

## Deployment Process
- **Terraform:**  
  Terrraform deploys the infrastructure, including S3 buckets, CloudFront distributions, API Gateway endpoints, Lambda functions, IAM roles, and Route 53 records. The `terraform/` directory contains all the necessary configurations to provision the AWS resources.
  
- **Landing Page: Static Content**  
  Your static and interactive pages are uploaded to Amazon S3. CloudFront serves these pages globally, while Route 53 routes DNS traffic to CloudFront.

- **Dynamic Content:**  
  The interactive page calls an API Gateway endpoint, which triggers the Lambda function in the `lambda/` folder to fetch or process data.

- **Terraform:**  
  Use Terraform to provision and update your infrastructure, ensuring a consistent and automated deployment process.

## Additional Notes

- **Security:**  
  Sensitive assets can be kept private by using specific S3 bucket policies and object ACLs. For example, you can configure policies to prevent public access to files in a `private/` directory.
  
- **Environment Management:**  
  The optional `environments/` folder under Terraform can be used to manage different configurations for development, staging, and production environments.

- **AWS Credentials:**  
  Make sure your AWS credentials are properly configured (via environment variables, AWS CLI configuration, or another method) before running Terraform commands.

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

## Acknowledgments

- [AWS Documentation](https://docs.aws.amazon.com/)
- [Terraform Documentation](https://www.terraform.io/docs)
- [Visual Studio Code Documentation](https://code.visualstudio.com/docs)


# File: ../Extraction/update_root_outputs_tf.py
# --------------------------------------------------
import os
import re






import os
import shutil

# Define variables
PROJECT_ROOT = "../JumpReact"
EXTRACTION_FOLDER = "../Extraction"
EXTRACTED_FILE = "aggregated_code.txt"
OUTPUT_FILENAME = ".terraform/outputs.tf"

def main(PROJECT_ROOT=PROJECT_ROOT, EXTRACTION_FOLDER=EXTRACTION_FOLDER, EXTRACTED_FILE=EXTRACTED_FILE, OUTPUT_FILENAME=OUTPUT_FILENAME):
    """Main function to extract files from the project directory."""
    def create_extraction_folder(extraction_path):
        """Create the extraction folder if it doesn't exist."""
        if not os.path.exists(extraction_path):
            os.makedirs(extraction_path)

    def copy_files_by_extension(source_dir, dest_dir, extensions, include_subdirs=False):
        """Copy files with specified extensions from source_dir to dest_dir."""
        if include_subdirs:
            for root, _, files in os.walk(source_dir):
                for file in files:
                    if file.endswith(tuple(extensions)):
                        src_file = os.path.join(root, file)
                        dest_file = os.path.join(dest_dir, file)
                        shutil.copy2(src_file, dest_file)
                        print(f"Copied: {src_file} -> {dest_file}")
        else:
            for file in os.listdir(source_dir):
                src_file = os.path.join(source_dir, file)
                if os.path.isfile(src_file) and file.endswith(tuple(extensions)):
                    dest_file = os.path.join(dest_dir, file)
                    shutil.copy2(src_file, dest_file)
                    print(f"Copied: {src_file} -> {dest_file}")

    def copy_subfolders(source_dir, dest_dir, subfolders):
        """Copy specific subfolders from source_dir to dest_dir."""
        for subfolder in subfolders:
            src_path = os.path.join(source_dir, subfolder)
            dest_path = os.path.join(dest_dir, subfolder)
            if os.path.exists(src_path):
                shutil.copytree(src_path, dest_path, dirs_exist_ok=True)
                print(f"Copied folder: {src_path} -> {dest_path}")

    def copy_specific_file(source_dir, dest_dir, filename):
        """Copy a specific file from source_dir to dest_dir."""
        src_file = os.path.join(source_dir, filename)
        dest_file = os.path.join(dest_dir, filename)
        if os.path.exists(src_file):
            shutil.copy2(src_file, dest_file)
            print(f"Copied: {src_file} -> {dest_file}")
        else:
            print(f"File not found: {src_file}")

    def gather_files(root_directory, output_file):
        if os.path.exists(output_file):
            os.remove(output_file)
        """
        Recursively walk through the root_directory, read each file’s content,
        and append it to the output_file with the file path as a header.
        """
        with open(output_file, 'w', encoding='utf-8') as out:
            for dirpath, _, filenames in os.walk(root_directory):
                for filename in filenames:
                    file_path = os.path.join(dirpath, filename)

                    # Optionally skip the output file if it happens to reside in the same folder
                    if file_path == os.path.abspath(output_file):
                        continue

                    # Write a header for the file
                    out.write(f"# File: {file_path}\n")
                    out.write("# --------------------------------------------------\n")

                    # Read and write the file contents
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            out.write(f.read())
                    except Exception as e:
                        # If there's an issue reading (e.g. it's a binary file), note the error
                        out.write(f"[Error reading file: {e}]\n")

                    # Add some spacing before the next file’s content
                    out.write("\n\n")
    TERRAFORM_SUBFOLDER = os.path.join(EXTRACTION_FOLDER, "terraform")
    TERRAFORM_PATH = os.path.join(PROJECT_ROOT, "terraform")

    def update_tf_output_variables(root_directory, output_file, excluded_subfolders=None):
        if os.path.exists(output_file):
            os.remove(output_file)
        
        if excluded_subfolders is None:
            excluded_subfolders = []
        
        with open(output_file, 'w', encoding='utf-8') as out:
            for dirpath, dirnames, filenames in os.walk(root_directory):
                # Skip directories that contain any of the excluded subfolder names in their path
                if any(excluded in dirpath for excluded in excluded_subfolders):
                    continue
                
                for filename in filenames:
                    if filename.startswith("outputs_") and filename.endswith(".tf"):
                        file_path = os.path.join(dirpath, filename)
                        
                        # Determine the module name from the file's parent folder name
                        folder_name = os.path.basename(os.path.dirname(file_path))
                        
                        # Write a header for the file in the output file
                        out.write(f"# File: {file_path}\n")
                        out.write("# --------------------------------------------------\n")
                        
                        # Read the file content
                        try:
                            with open(file_path, 'r', encoding='utf-8') as f:
                                content = f.read()
                        except Exception as e:
                            out.write(f"[Error reading file: {e}]\n")
                            continue
                        
                        # Process file content line by line
                        lines = content.splitlines(keepends=True)
                        in_output_block = False
                        current_output = None
                        new_lines = []
                        
                        for line in lines:
                            # Look for the start of an output block and capture the output variable name
                            header_match = re.match(r'^\s*output\s+"([^"]+)"\s*{', line)
                            if header_match:
                                current_output = header_match.group(1)
                                in_output_block = True
                                new_lines.append(line)
                                continue
                            
                            # When inside an output block, replace the value assignment line
                            if in_output_block and re.match(r'^\s*value\s*=.*', line):
                                indent = re.match(r'^(\s*)', line).group(1)
                                # Replace with a module reference in the format: module.<folder_name>.<variable_name>
                                new_value_line = f'{indent}value       = module.{folder_name}.{current_output}\n'
                                new_lines.append(new_value_line)
                                continue
                            
                            # Detect the end of the output block
                            if in_output_block and re.match(r'^\s*}\s*$', line):
                                in_output_block = False
                                current_output = None
                                new_lines.append(line)
                                continue
                            
                            # For all other lines, keep them unchanged
                            new_lines.append(line)
                        
                        transformed_content = ''.join(new_lines)
                        out.write(transformed_content)
                        
                        # Add spacing before the next file’s content
                        out.write("\n\n")

    create_extraction_folder(EXTRACTION_FOLDER)
    create_extraction_folder(TERRAFORM_SUBFOLDER)
    
    # Root level files
    copy_files_by_extension(PROJECT_ROOT, EXTRACTION_FOLDER, [".py", ".json"], include_subdirs=False)
    copy_files_by_extension(PROJECT_ROOT, EXTRACTION_FOLDER, [".sh", ".md"], include_subdirs=False)
    copy_subfolders(PROJECT_ROOT, EXTRACTION_FOLDER, ["app", "lambda"])

    # Terraform folder level files
    copy_subfolders(TERRAFORM_PATH, TERRAFORM_SUBFOLDER, ["modules"])
    copy_files_by_extension(TERRAFORM_PATH, TERRAFORM_SUBFOLDER, [".tf"], include_subdirs=False)
    copy_specific_file(TERRAFORM_PATH, TERRAFORM_SUBFOLDER, "secrets.tfvars")
    
    print("Extraction process completed!")
    
    # Consolidate extracted files into a single file
    gather_files(EXTRACTION_FOLDER, EXTRACTED_FILE)
    # delete the extraction folder
    shutil.rmtree(EXTRACTION_FOLDER)
    print("Done! aggregated_code.txt")
    

    update_tf_output_variables("./terraform", OUTPUT_FILENAME)
    print("Done! outputs.tf")

    
if __name__ == "__main__":
    main()




# File: ../Extraction/app/index.html
# --------------------------------------------------
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Welcome to Our Site</title>
    <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <h1>Welcome to Our Static Webpage</h1>
    <p>This page is served from S3 and accelerated with CloudFront.</p>
    <!-- Button to navigate to the interactive page -->
    <a href="/myspotify/index.html">
      <button>Click to login to Spotify to see playlist summary statistics</button>
    </a>
  </body>
</html>


# File: ../Extraction/app/styles.css
# --------------------------------------------------
/* styles.css */

/* Basic reset */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  body {
    font-family: Arial, sans-serif;
    background-color: #f4f4f4;
    line-height: 1.6;
    color: #333;
    padding: 20px;
  }
  
  .site-header {
    background-color: #333;
    color: #fff;
    padding: 20px;
    text-align: center;
  }
  
  .site-content {
    max-width: 800px;
    margin: 20px auto;
    padding: 20px;
    background: #fff;
    border-radius: 4px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  }
  
  .btn {
    display: inline-block;
    margin-top: 20px;
    padding: 10px 20px;
    background-color: #007BFF;
    color: #fff;
    text-decoration: none;
    border-radius: 4px;
    transition: background-color 0.3s ease;
  }
  
  .btn:hover {
    background-color: #0056b3;
  }
  

# File: ../Extraction/app/myspotify/index.html
# --------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Spotify Featured Playlists</title>
  <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<body>
  <h1>Featured Playlists</h1>
  <div id="playlists">Loading playlists...</div>
  <script src="scripts/main.js"></script>
</body>
</html>

# File: ../Extraction/app/myspotify/main.js.tmpl
# --------------------------------------------------
// main.js

// Replace with your actual API Gateway URL
const apiUrl = "https://portfolio-lambda-function.execute-api.us-east-2.amazonaws.com/prod/data";

// Initialize the chart using Chart.js
const ctx = document.getElementById('dataChart').getContext('2d');
let chart = new Chart(ctx, {
  type: 'bar',
  data: {
    labels: ['Value'],
    datasets: [{
      label: 'Dynamic Value',
      data: [0],
      backgroundColor: 'rgba(75, 192, 192, 0.2)',
      borderColor: 'rgba(75, 192, 192, 1)',
      borderWidth: 1
    }]
  },
  options: {
    scales: {
      y: { beginAtZero: true }
    }
  }
});

// Function to fetch JSON data from your API and update the chart
async function updateChart() {
  try {
    const response = await fetch(apiUrl);
    const result = await response.json();
    // Assuming your JSON response has a property "value"
    chart.data.datasets[0].data[0] = result.value;
    chart.update();
  } catch (error) {
    console.error('Error fetching data:', error);
  }
}

// Update the chart
updateChart();


# File: ../Extraction/app/myspotify/styles.css
# --------------------------------------------------
/* styles.css */
body {
  font-family: Arial, sans-serif;
  margin: 20px;
  background-color: #f4f4f4;
}

h1 {
  color: #333;
}

.playlist {
  background: #fff;
  border: 1px solid #ddd;
  padding: 10px;
  margin-bottom: 10px;
}

a {
  color: #1db954;
  text-decoration: none;
}


# File: ../Extraction/app/static/index.html
# --------------------------------------------------
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Welcome to Our Site</title>
    <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <h1>Welcome to Our Static Webpage</h1>
    <p>This page is served from S3 and accelerated with CloudFront.</p>
    <!-- Button to navigate to the interactive page -->
    <a href="/interactive/index.html">
      <button>View My Spotify Playlist Visualization</button>
    </a>
  </body>
</html>


# File: ../Extraction/app/static/styles.css
# --------------------------------------------------
/* styles.css */

/* Basic reset */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  body {
    font-family: Arial, sans-serif;
    background-color: #f4f4f4;
    line-height: 1.6;
    color: #333;
    padding: 20px;
  }
  
  .site-header {
    background-color: #333;
    color: #fff;
    padding: 20px;
    text-align: center;
  }
  
  .site-content {
    max-width: 800px;
    margin: 20px auto;
    padding: 20px;
    background: #fff;
    border-radius: 4px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  }
  
  .btn {
    display: inline-block;
    margin-top: 20px;
    padding: 10px 20px;
    background-color: #007BFF;
    color: #fff;
    text-decoration: none;
    border-radius: 4px;
    transition: background-color 0.3s ease;
  }
  
  .btn:hover {
    background-color: #0056b3;
  }
  

# File: ../Extraction/lambda/data_extractor.py
# --------------------------------------------------
import os
import requests
import base64
import json
import boto3

# Replace these with your own or store them in environment variables
CLIENT_ID = os.environ.get("SPOTIFY_CLIENT_ID", "YOUR_CLIENT_ID")
CLIENT_SECRET = os.environ.get("SPOTIFY_CLIENT_SECRET", "YOUR_CLIENT_SECRET")

# Must match the Redirect URI in your Spotify Developer Dashboard
REDIRECT_URI = "http://localhost:8888/callback"

# The scope needed to read a user’s private playlists
SCOPE = "playlist-read-private playlist-read-collaborative"

# Spotify Authorization endpoint
AUTHORIZE_URL = "https://accounts.spotify.com/authorize"
# Spotify Token endpoint
TOKEN_URL = "https://accounts.spotify.com/api/token"

def generate_auth_url():
    """
    Generate the URL that the user must visit to allow
    your app to access their Spotify account.
    """
    params = {
        "client_id": CLIENT_ID,
        "response_type": "code",
        "redirect_uri": REDIRECT_URI,
        "scope": SCOPE
    }
    # Convert these params into a query string
    query = "&".join([f"{key}={requests.utils.quote(value)}" for key, value in params.items()])
    return f"{AUTHORIZE_URL}?{query}"

if __name__ == "__main__":
    auth_url = generate_auth_url()
    print("Visit this URL to authorize the application:\n")
    print(auth_url)


# File: ../Extraction/lambda/lambda_function.py
# --------------------------------------------------
import json
import os
import requests
import base64
import boto3

def get_spotify_credentials(secret_name="SpotifyCredentials", region_name="us-east-1"):

    session = boto3.session.Session()
    client = session.client(service_name="secretsmanager", region_name=region_name)

    try:
        get_secret_value_response = client.get_secret_value(SecretId=secret_name)
    except Exception as e:
        raise Exception(f"Error retrieving secret {secret_name}: {str(e)}")

    # Check if the secret is a string or binary
    if "SecretString" in get_secret_value_response:
        secret = get_secret_value_response["SecretString"]
    else:
        secret = base64.b64decode(get_secret_value_response["SecretBinary"]).decode('utf-8')

    credentials = json.loads(secret)
    return credentials["SPOTIFY_CLIENT_ID"], credentials["SPOTIFY_CLIENT_SECRET"]

def lambda_handler(event, context):
    # Retrieve region from environment variable (or default)
    region = os.environ.get("AWS_REGION", "us-east-1")
    s3_bucket = os.environ.get("S3_BUCKET_NAME")
    secret_name = os.environ.get("SECRET_NAME")

    try:
        client_id, client_secret = get_spotify_credentials(secret_name=secret_name, region_name=region)
    except Exception as e:
        return {
            "statusCode": 500,
            "headers": {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*"
            },
            "body": json.dumps({"error": f"Failed to retrieve Spotify credentials: {str(e)}"})
        }
    
    # Get an access token from Spotify using the Client Credentials Flow
    auth_url = "https://accounts.spotify.com/api/token"
    auth_str = f"{client_id}:{client_secret}"
    b64_auth_str = base64.b64encode(auth_str.encode()).decode("utf-8")
    auth_headers = {"Authorization": f"Basic {b64_auth_str}"}
    auth_data = {"grant_type": "client_credentials"}

    auth_response = requests.post(auth_url, headers=auth_headers, data=auth_data)
    if auth_response.status_code != 200:
        return {
            "statusCode": 500,
            "headers": {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*"
            },
            "body": json.dumps({
                "error": "Failed to authenticate with Spotify",
                "details": auth_response.text
            })
        }
    
    access_token = auth_response.json()["access_token"]

    # Fetch data from Spotify: Example using the Featured Playlists endpoint
    spotify_url = "https://api.spotify.com/v1/browse/featured-playlists"
    headers = {"Authorization": f"Bearer {access_token}"}
    spotify_response = requests.get(spotify_url, headers=headers)
    if spotify_response.status_code != 200:
        return {
            "statusCode": 500,
            "headers": {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*"
            },
            "body": json.dumps({
                "error": "Failed to fetch Spotify data",
                "details": spotify_response.text
            })
        }
    spotify_data = spotify_response.json()

    # Process the Spotify data: extract playlist names and URLs as an example
    processed_data = {
        "playlists": [
            {
                "name": playlist["name"],
                "url": playlist["external_urls"]["spotify"]
            }
            for playlist in spotify_data.get("playlists", {}).get("items", [])
        ]
    }

    s3 = boto3.client("s3", region_name=region)
    object_key = "data/spotify_data.json"
    s3.put_object(
        Bucket=s3_bucket,
        Key=object_key,
        Body=json.dumps(processed_data),
        ContentType="application/json"
    )

    # Return the processed data as a JSON response with CORS enabled
    return {
        "statusCode": 200,
        "headers": {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
        },
        "body": json.dumps(processed_data)
    }

# File: ../Extraction/lambda/lambda_function.zip
# --------------------------------------------------
[Error reading file: 'utf-8' codec can't decode byte 0x8a in position 13: invalid start byte]


# File: ../Extraction/terraform/data.tf
# --------------------------------------------------
data "aws_secretsmanager_secret" "spotify_secret" {
  name = var.secrets_manager_secret_name
}

# Route 53 DNS record to point your domain to CloudFront
data "aws_route53_zone" "existing" {
  name         = "${var.website_domain_name}."
  private_zone = false
}

data "archive_file" "lambda" {
  type        = "zip"
  source_file = "${var.lambda_path}${var.lambda_file}"
  output_path = local.lambda_zip_path
}

# File: ../Extraction/terraform/locals.tf
# --------------------------------------------------
locals {
  resource_prefix                 = "${var.project_name}"
  lambda_zip_path                 = "${var.lambda_path}${var.lambda_filename}"
  lambda_role_name                = "${local.resource_prefix}-lambda-role"
  lambda_policy_name              = "${local.resource_prefix}-lambda-policy"
  oac_name                        = "${local.resource_prefix}-oac"
  cloudfront_origin_id            = "${local.resource_prefix}-s3-origin-${random_integer.random_id.result}"
  cloudfront_distribution_comment = "${local.resource_prefix} CloudFront Distribution"
  acm_certificate_name            = "${local.resource_prefix}-acm-cert"
  cloudfront_distribution_arn     = "${local.resource_prefix}-cloudfront-dist-${random_integer.random_id.result}"
  iam_role_name                   = "${local.resource_prefix}-iam-role"
  lambda_function_name            = "${local.resource_prefix}-lambda-function"
  bucket_name                     = "${local.resource_prefix}-bucket-${random_integer.random_id.result}"
  cloudfront_aliases              = concat([var.website_domain_name], var.website_alternative_names)
    s3_source_list = concat(var.s3_file_list,[local_file.script_file.filename])


  lambda_environment_variables    = {
    SPOTIFY_CLIENT_ID     = var.spotify_client_id
    SPOTIFY_CLIENT_SECRET = var.spotify_client_secret
  }

  spotify_js_content              = templatefile("${var.frontend_path}${var.spotify_js_template}", {
    cloudfront_domain = module.cloudfront.cloudfront_distribution_domain_name
    api_id            = local.lambda_function_name
    region            = var.aws_region
  })

  s3_files_map = {
    for file in local.s3_source_list : file => {
      s3_key = file
      source = "${var.frontend_path}${file}"
      content_type = (
        endswith(file, ".html") ? "text/html" :
        endswith(file, ".css")  ? "text/css"  :
        endswith(file, ".js")   ? "application/javascript" :
        "application/octet-stream"
      )
    }
  }
}

resource "local_file" "script_file" {
  content  = local.spotify_js_content
  filename = "${var.frontend_path}${var.spotify_js_template}"
}


# File: ../Extraction/terraform/main.tf
# --------------------------------------------------
resource "random_integer" "random_id" {
  min = 1000
  max = 9999
  lifecycle {
    prevent_destroy = true 
  }
}

module "acm" {
  source                    = "./modules/acm"
  providers = {
    aws.us_east_1 = aws.us_east_1
  }
  acm_certificate_name      = local.acm_certificate_name
  domain_name               = var.website_domain_name
  project_name              = var.project_name
  subject_alternative_names = var.website_alternative_names
  route53_hosted_zone_id    = data.aws_route53_zone.existing.zone_id
}
  

module "cloudfront" {
  source                          = "./modules/cloudfront"
  cloudfront_origin_id            = local.cloudfront_origin_id
  cloudfront_price_class          = var.cloudfront_price_class
  acm_certificate_arn             = module.acm.acm_certificate_arn
  cloudfront_distribution_comment = local.cloudfront_distribution_comment
  oac_name                        = local.oac_name
  cloudfront_aliases              = local.cloudfront_aliases
  project_name                    = var.project_name
  s3_bucket_domain_name           = module.s3.s3_bucket_domain_name
}

module "iam" {
  source                      = "./modules/iam"
  lambda_role_name            = local.lambda_role_name
  lambda_policy_name          = local.lambda_policy_name
  lambda_s3_resource_arn      = module.s3.s3_bucket_arn
  lambda_secrets_manager_arn  = module.secretsmanager.secrets_manager_secret_arn
}

module "lambda" {
  source                        = "./modules/lambda"
  lambda_function_name          = local.lambda_function_name
  lambda_zip_path               = local.lambda_zip_path
  lambda_runtime                = var.lambda_runtime
  lambda_role_arn               = module.iam.lambda_role_arn 
  lambda_environment_variables  = local.lambda_environment_variables
}

module "route53" {
  source                                    = "./modules/route53"
  website_domain_name                       = var.website_domain_name
  cloudfront_distribution_domain_name       = module.cloudfront.cloudfront_distribution_domain_name
  cloudfront_distribution_hosted_zone_id    = module.cloudfront.cloudfront_distribution_hosted_zone_id
  route53_hosted_zone_id                    = data.aws_route53_zone.existing.zone_id
  acm_certificate_arn                       = module.acm.acm_certificate_arn
  website_alternative_names                 = var.website_alternative_names
}

module "s3" {
  source                      = "./modules/s3"
  project_name                = var.project_name
  bucket_name                 = local.bucket_name  
}

module "s3_policy" {
  source                      = "./modules/s3_policy"
  bucket_name                 = module.s3.bucket_name         # Ensure your S3 module outputs the bucket name
  bucket_arn                  = module.s3.s3_bucket_arn       # Ensure your S3 module outputs the bucket ARN
  cloudfront_distribution_arn = module.cloudfront.cloudfront_distribution_arn
}

module "s3_uploads" {
  source                      = "./modules/s3_uploads"
  s3_files_map                = local.s3_files_map
  s3_bucket_id                = module.s3.s3_bucket_id
}

module "secretsmanager" {
  source                      = "./modules/secretsmanager"
  secrets_id                  = data.aws_secretsmanager_secret.spotify_secret.id
  spotify_secrets             = local.lambda_environment_variables
}

# File: ../Extraction/terraform/outputs.tf
# --------------------------------------------------
# File: ./terraform/modules/acm/outputs_acm.tf
# --------------------------------------------------
output "acm_certificate_arn" {
  value       = module.acm.acm_certificate_arn
}


# File: ./terraform/modules/cloudfront/outputs_cloudfront.tf
# --------------------------------------------------
output "cloudfront_distribution_domain_name" {
  description = "The domain name of the CloudFront distribution"
  value       = module.cloudfront.cloudfront_distribution_domain_name
}

output "cloudfront_origin_access_control_id" {
  description = "The ID of the Origin Access Control (OAC) for CloudFront"
  value       = module.cloudfront.cloudfront_origin_access_control_id
}

output "cloudfront_distribution_hosted_zone_id" {
  description = "The hosted zone ID of the CloudFront distribution"
  value       = module.cloudfront.cloudfront_distribution_hosted_zone_id
}

output "cloudfront_distribution_id" {
  description = "The ID of the CloudFront distribution"
  value       = module.cloudfront.cloudfront_distribution_id
}

output "cloudfront_distribution_arn" {
  description = "The ARN of the CloudFront distribution"
  value       = module.cloudfront.cloudfront_distribution_arn
}

# File: ./terraform/modules/iam/outputs_iam.tf
# --------------------------------------------------
output "lambda_role_arn" {
  description = "The ARN of the Lambda execution role"
  value       = module.iam.lambda_role_arn
}

# File: ./terraform/modules/lambda/outputs_lambda.tf
# --------------------------------------------------
output "lambda_function_arn" {
  description = "The ARN of the Lambda function"
  value       = module.lambda.lambda_function_arn
}

output "lambda_function_name" {
  description = "The name of the Lambda function"
  value       = module.lambda.lambda_function_name
}

# File: ./terraform/modules/route53/outputs_route53.tf
# --------------------------------------------------
output "route53_record_fqdn" {
  description = "The DNS record created for the domain"
  value       = module.route53.route53_record_fqdn
}

# File: ./terraform/modules/s3/outputs_s3.tf
# --------------------------------------------------
output "bucket_name" {
  description = "The name of the S3 bucket"
  value       = module.s3.bucket_name
}

output "s3_bucket_arn" {
  description = "The ARN of the S3 bucket"
  value       = module.s3.s3_bucket_arn
}

output "s3_bucket_id" {
  description = "The ID of the S3 bucket"
  value       = module.s3.s3_bucket_id
}

# File: ./terraform/modules/s3_policy/outputs_s3_policy.tf
# --------------------------------------------------


# File: ./terraform/modules/s3_uploads/outputs_s3_uploads.tf
# --------------------------------------------------
# 3. Output the object key or anything else needed
output "uploaded_keys" {
  description = "The S3 object key for the uploaded JS file"
  value       = module.s3_uploads.uploaded_keys
}

# File: ./terraform/modules/secretsmanager/outputs_secrets_manager.tf
# --------------------------------------------------
output "secrets_manager_secret_arn" {
  description = "The ARN of the Secrets Manager secret"
  value       = module.secretsmanager.secrets_manager_secret_arn
}



# File: ../Extraction/terraform/providers.tf
# --------------------------------------------------
terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 4.0"
    }
  }
}


provider "aws" {
  region = var.aws_region
}

provider "aws" {
  alias  = "us_east_1"
  region = "us-east-1"
}



# File: ../Extraction/terraform/secrets.tfvars
# --------------------------------------------------
################################################################################
# Terraform Variables
################################################################################
# Region Variables
aws_region = "us-east-2"   # e.g. "us-east-1"

# Profile Variables
project_name                = "portfolio"
website_domain_name         = "babasanmiadeyemiportfolio.com"   # e.g. "example.com"
website_alternative_names   = ["www.babasanmiadeyemiportfolio.com"]
secrets_manager_secret_name = "SpotifySecrets"
cloudfront_price_class      = "PriceClass_100"

# Secrets / Lambda Environment Variables
spotify_client_id       = "REDACTED_CLIENT_ID" 
spotify_client_secret   = "REDACTED_CLIENT_SECRET"
lambda_runtime          = "python3.8"



# Local paths and configurations
frontend_path       = "../app/"
lambda_path         = "../lambda/"
lambda_file         = "lambda_function.py"
lambda_filename     = "lambda_function.zip"

# S3 Bucket Files
s3_file_list = [
  "index.html",
  "styles.css",
  "myspotify/index.html",
  "myspotify/styles.css"
]
spotify_js_template = "myspotify/main.js.tmpl"
################################################################################
# End of File
################################################################################

# File: ../Extraction/terraform/variables.tf
# --------------------------------------------------
# Provider variables
variable "aws_region" {
  description = "The AWS region"
  type        = string
}

variable "project_name" {
  description = "The project name"
  type        = string
} 


variable "website_domain_name" {
  description = "The website domain name"
  type        = string
}

variable "secrets_manager_secret_name" {
  description = "The name of the secret in Secrets Manager"
  type        = string
}

variable "spotify_client_id" {
  description = "Spotify client ID"
  type        = string
  sensitive   = true
}

variable "spotify_client_secret" {
  description = "Spotify client secret"
  type        = string
  sensitive   = true
}

variable "lambda_runtime" {
  description = "The runtime for the Lambda function"
  type        = string
}

variable "lambda_filename" {
  description = "The filename of the Lambda function code"
  type        = string
}

variable "lambda_path" {
  description = "The path to the Lambda function code"
  type        = string
  
} 

variable "cloudfront_price_class" {
  description = "The price class for the CloudFront distribution"
  type        = string
  default = "PriceClass_100"
}

variable "frontend_path" {
  description = "The path to the frontend files"
  type        = string
}

variable "website_alternative_names" {
  description = "Alternative names for the website"
  type        = list(string)
  default     = []
}

variable "lambda_file" {
  description = "The name of the Lambda function file"
  type        = string  
}

variable "s3_file_list" {
  description = "List of files to upload to S3"
  type        = list(string)
}

variable "spotify_js_template" {
  description = "The template file for the Spotify JavaScript"
  type        = string
}
################################################################################
# End of File
################################################################################


# File: ../Extraction/terraform/modules/acm/main_acm.tf
# --------------------------------------------------
# import the provider configuration from the root module
terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"

      configuration_aliases = [
        aws.us_east_1
      ]
    } 
  }
}
resource "aws_acm_certificate" "cert" {
  provider                  = aws.us_east_1
  domain_name               = var.domain_name
  validation_method         = "DNS"
  subject_alternative_names = var.subject_alternative_names

  tags = {
    Name    = var.acm_certificate_name
    Project = var.project_name
  }
}

resource "aws_acm_certificate_validation" "cert_validation" {
  provider               = aws.us_east_1
  certificate_arn         = aws_acm_certificate.cert.arn
  validation_record_fqdns = [for record in aws_route53_record.cert_validation : record.fqdn]
  }

resource "aws_route53_record" "cert_validation" {
  provider = aws.us_east_1
  for_each = {
    for dvo in aws_acm_certificate.cert.domain_validation_options : dvo.domain_name => {
      name   = dvo.resource_record_name
      type   = dvo.resource_record_type
      record = dvo.resource_record_value
    }
  }

  zone_id = var.route53_hosted_zone_id
  name    = each.value.name
  type    = each.value.type
  records = [each.value.record]
  ttl     = 60
}

# File: ../Extraction/terraform/modules/acm/outputs_acm.tf
# --------------------------------------------------
output "acm_certificate_arn" {
  value = aws_acm_certificate.cert.arn
}

output "acm_certificate_domain_validation_options" {
  value = aws_acm_certificate.cert.domain_validation_options
}

# File: ../Extraction/terraform/modules/acm/variables_acm.tf
# --------------------------------------------------
variable "project_name" {
  type        = string
  description = "Project name for resource naming"
}

variable "domain_name" {
  type        = string
  description = "Primary domain name for the certificate"
}

variable "subject_alternative_names" {
  type        = list(string)
  description = "Additional domain names for the certificate"
  default     = []
}


variable "acm_certificate_name" {
  type        = string
  description = "Name tag for the ACM certificate"
}

variable "route53_hosted_zone_id" {
  type        = string
  description = "The ID of the Route 53 hosted zone for DNS validation"
}

# File: ../Extraction/terraform/modules/cloudfront/main_cloudfront.tf
# --------------------------------------------------
# CloudFront distribution in front of the S3 bucket
resource "aws_cloudfront_origin_access_control" "oac" {
  name                              = var.oac_name
  description                       = "Origin Access Control for S3"
  origin_access_control_origin_type = "s3"
  signing_behavior                  = "always"
  signing_protocol                  = "sigv4"
}

resource "aws_cloudfront_distribution" "this" {
  price_class         = var.cloudfront_price_class
  enabled             = true
  # is_ipv6_enabled     = true
  comment             = var.cloudfront_distribution_comment
  aliases             = var.cloudfront_aliases
  default_root_object = "index.html"

  origin {
    domain_name               = var.s3_bucket_domain_name
    origin_id                 = var.cloudfront_origin_id
    origin_access_control_id  = aws_cloudfront_origin_access_control.oac.id
  }

  # Default cache behavior
  default_cache_behavior {
    target_origin_id       = var.cloudfront_origin_id
    allowed_methods        = ["GET", "HEAD", "OPTIONS"]
    cached_methods         = ["GET", "HEAD", "OPTIONS"]
    viewer_protocol_policy = "redirect-to-https"
    
    compress    = true    
    min_ttl     = 0
    default_ttl = 86400
    max_ttl     = 31536000

    forwarded_values {
      query_string = false
      cookies {
        forward = "none"
      }
    }
  }

  restrictions {
    geo_restriction {
      restriction_type = "none"
    }
  }

  viewer_certificate {
    acm_certificate_arn = var.acm_certificate_arn
    ssl_support_method  = "sni-only"
  }
  tags = {
    Name = var.cloudfront_distribution_comment
    project = var.project_name
  }
}


# File: ../Extraction/terraform/modules/cloudfront/outputs_cloudfront.tf
# --------------------------------------------------
output "cloudfront_distribution_domain_name" {
  description = "The domain name of the CloudFront distribution"
  value       = aws_cloudfront_distribution.this.domain_name
}

output "cloudfront_origin_access_control_id" {
  description = "The ID of the Origin Access Control (OAC) for CloudFront"
  value       = aws_cloudfront_origin_access_control.oac.id
}

output "cloudfront_distribution_hosted_zone_id" {
  description = "The hosted zone ID of the CloudFront distribution"
  value       = aws_cloudfront_distribution.this.hosted_zone_id
}

output "cloudfront_distribution_id" {
  description = "The ID of the CloudFront distribution"
  value       = aws_cloudfront_distribution.this.id
}

output "cloudfront_distribution_arn" {
  description = "The ARN of the CloudFront distribution"
  value       = aws_cloudfront_distribution.this.arn
}

# File: ../Extraction/terraform/modules/cloudfront/variables_cloudfront.tf
# --------------------------------------------------
variable "project_name" {
  type        = string
  description = "Project name for resource naming"
}


variable "oac_name" {
  description = "The name of the Origin Access Control (OAC)"
  type        = string
}

variable "cloudfront_origin_id" {
  description = "The ID of the origin (S3 bucket)"
  type        = string
}

variable "s3_bucket_domain_name" {
  type        = string
  description = "S3 bucket domain name for CloudFront origin (e.g., bucket-name.s3.amazonaws.com)"
}

variable "cloudfront_aliases" {
  type        = list(string)
  description = "List of domain aliases for the CloudFront distribution"
}

variable "acm_certificate_arn" {
  type        = string
  description = "ARN of the ACM certificate covering the domain"
}

variable "additional_origins" {
  type = list(object({
    domain_name            = string
    origin_id              = string
    http_port              = optional(number, 80)
    https_port             = optional(number, 443)
    origin_protocol_policy = optional(string, "https-only")
    origin_ssl_protocols   = optional(list(string), ["TLSv1.2"])
  }))
  description = "Additional origins for CloudFront"
  default     = []
}

variable "cloudfront_price_class" {
  type        = string
  description = "Price class for the CloudFront distribution (e.g., PriceClass_100, PriceClass_200, PriceClass_All)"
}

variable "cloudfront_distribution_comment" {
  type        = string
  description = "Comment for the CloudFront distribution"
}

# File: ../Extraction/terraform/modules/iam/main_iam.tf
# --------------------------------------------------
# IAM role for Lambda execution
resource "aws_iam_role" "lambda_exec_role" {
  name = var.lambda_role_name
  assume_role_policy = jsonencode({
    Version = "2012-10-17",
    Statement = [{
      Action    = "sts:AssumeRole",
      Effect    = "Allow",
      Principal = {
        Service = "lambda.amazonaws.com"
      }
    }]
  })
}

resource "aws_iam_role_policy" "lambda_policy" {
  name = var.lambda_policy_name
  role = aws_iam_role.lambda_exec_role.id
  policy = jsonencode({
    Version   = "2012-10-17",
    Statement = [
      {
        Effect   = "Allow",
        Action   = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ],
        Resource = "arn:aws:logs:*:*:*"
      },
      {
        Effect   = "Allow",
        Action   = [
          "s3:PutObject",
          "s3:GetObject",
          "s3:ListBucket"
        ],
        Resource = var.lambda_s3_resource_arn 
      },
      {
        Effect   = "Allow",
        Action   = [ "secretsmanager:GetSecretValue" ],
        Resource = var.lambda_secrets_manager_arn
      }
    ]
  })
}

# File: ../Extraction/terraform/modules/iam/outputs_iam.tf
# --------------------------------------------------
output "lambda_role_arn" {
  description = "The ARN of the Lambda execution role"
  value       = aws_iam_role.lambda_exec_role.arn
}

# File: ../Extraction/terraform/modules/iam/variables_iam.tf
# --------------------------------------------------
variable "lambda_role_name" {
  description = "Name of the IAM role"
  type        = string
}

variable "lambda_policy_name" {
  description = "Name of the IAM policy"
  type        = string
}
variable "lambda_s3_resource_arn" {
  description = "ARN of the S3 bucket objects to be accessed by the Lambda function"
  type        = string
}

variable "lambda_secrets_manager_arn" {
  description = "ARN of the Secrets Manager secret"
  type        = string
}

# File: ../Extraction/terraform/modules/lambda/main_lambda.tf
# --------------------------------------------------
resource "aws_lambda_function" "data_processor" {
  function_name    = var.lambda_function_name
  handler          = "lambda_function.lambda_handler"
  runtime          = var.lambda_runtime
  role             = var.lambda_role_arn
  filename         = var.lambda_zip_path
  source_code_hash = filebase64sha256(var.lambda_zip_path)
  timeout          = 300
  environment {
    variables = var.lambda_environment_variables
  }
}



# File: ../Extraction/terraform/modules/lambda/outputs_lambda.tf
# --------------------------------------------------
output "lambda_function_arn" {
  description = "The ARN of the Lambda function"
  value       = aws_lambda_function.data_processor.arn
}

output "lambda_function_name" {
  description = "The name of the Lambda function"
  value       = aws_lambda_function.data_processor.function_name
}

# File: ../Extraction/terraform/modules/lambda/variables_lambda.tf
# --------------------------------------------------
variable "lambda_function_name" {
  description = "The name of the IAM role for Lambda execution"
  type        = string
}

variable "lambda_zip_path" {
  description = "The path to the zipped Python Lambda function code"
  type        = string
}

variable "lambda_role_arn" {
  description = "The ARN of the IAM role for Lambda execution"
  type        = string
}

variable "lambda_runtime" {
  description = "The runtime for the Lambda function"
  type        = string
}

variable "lambda_environment_variables" {
  description = "Environment variables for the Lambda function"
  type        = map(string)
}



# File: ../Extraction/terraform/modules/route53/main_route53.tf
# --------------------------------------------------


resource "aws_route53_record" "static_site_record" {
  zone_id = var.route53_hosted_zone_id
  name    = var.website_domain_name
  type    = "A"

  alias {
    name                   = var.cloudfront_distribution_domain_name
    zone_id                = var.cloudfront_distribution_hosted_zone_id
    evaluate_target_health = false
  }
}

resource "aws_route53_record" "alternative_aliases" {
  for_each = toset(var.website_alternative_names)
  zone_id  = var.route53_hosted_zone_id
  name     = each.value
  type     = "A"

  alias {
    name                   = var.cloudfront_distribution_domain_name
    zone_id                = var.cloudfront_distribution_hosted_zone_id
    evaluate_target_health = false
  }
}


# File: ../Extraction/terraform/modules/route53/outputs_route53.tf
# --------------------------------------------------
output "route53_record_fqdn" {
  description = "The DNS record created for the domain"
  value       = aws_route53_record.static_site_record.fqdn
}

# File: ../Extraction/terraform/modules/route53/variables_route53.tf
# --------------------------------------------------
variable "website_domain_name" {
  description = "The domain name of the website"
  type        = string
}

variable "cloudfront_distribution_domain_name" {
  description = "The domain name of the CloudFront distribution"
  type        = string
}

variable "cloudfront_distribution_hosted_zone_id" {
  description = "The ID of the CloudFront hosted zone"
  type        = string
}

variable "route53_hosted_zone_id" {
  description = "The ID of the Route 53 hosted zone"
  type        = string
}

variable "acm_certificate_arn" {
  type        = string
  description = "The ARN of the ACM certificate"
}

variable "website_alternative_names" {
  description = "A list of alternative domain names for the website"
  type        = list(string)
}

# File: ../Extraction/terraform/modules/s3/main_s3.tf
# --------------------------------------------------

# S3 Bucket for the static webpage
resource "aws_s3_bucket" "website" {
  bucket = var.bucket_name
  
  tags = {
    Name        = var.bucket_name
    project     = var.project_name
  }
}

# Enable public access to the S3 bucket
resource "aws_s3_bucket_public_access_block" "website_private_access" {
    bucket                  = aws_s3_bucket.website.id
    block_public_acls       = true
    block_public_policy     = true
    ignore_public_acls      = true
    restrict_public_buckets = true
}

resource "aws_s3_bucket_ownership_controls" "website_ownership" {
  bucket = aws_s3_bucket.website.id
  rule {
    object_ownership = "BucketOwnerPreferred"
  }
}


# File: ../Extraction/terraform/modules/s3/outputs_s3.tf
# --------------------------------------------------
output "bucket_name" {
  description = "The name of the S3 bucket"
  value       = aws_s3_bucket.website.bucket
}

output "s3_bucket_arn" {
  description = "The ARN of the S3 bucket"
  value       = aws_s3_bucket.website.arn
}

output "s3_bucket_id" {
  description = "The ID of the S3 bucket"
  value       = aws_s3_bucket.website.id
}

output "s3_bucket_domain_name" {
  description = "The domain name of the S3 bucket"
  value       = aws_s3_bucket.website.bucket_domain_name
  
}

# File: ../Extraction/terraform/modules/s3/variables_s3.tf
# --------------------------------------------------
variable "project_name" {
  description = "The name of the project"
  type        = string
  
}

variable "bucket_name" {
  description = "The name of the S3 bucket"
  type        = string
}


# File: ../Extraction/terraform/modules/s3_policy/main_s3_policy.tf
# --------------------------------------------------
resource "aws_s3_bucket_policy" "website_policy" {
  bucket = var.bucket_name

  policy = jsonencode({
    "Version": "2012-10-17",
    "Statement": [
      {
        "Sid": "AllowCloudFrontServicePrincipal",
        "Effect": "Allow",
        "Principal": {
          "Service": "cloudfront.amazonaws.com"
        },
        "Action": "s3:GetObject",
        "Resource": "${var.bucket_arn}/*",
        "Condition": {
          "StringEquals": {
            "AWS:SourceArn": var.cloudfront_distribution_arn
          }
        }
      }
    ]
  })
}




# File: ../Extraction/terraform/modules/s3_policy/outputs_s3_policy.tf
# --------------------------------------------------


# File: ../Extraction/terraform/modules/s3_policy/variables_s3_policy.tf
# --------------------------------------------------
variable "bucket_name" {
  description = "The name of the S3 bucket"
  type        = string
}

variable "bucket_arn" {
  description = "The ARN of the S3 bucket"
  type        = string
}

variable "cloudfront_distribution_arn" {
  description = "The ARN of the CloudFront distribution"
  type        = string
}


# File: ../Extraction/terraform/modules/s3_uploads/main_s3_uploads.tf
# --------------------------------------------------
resource "aws_s3_object" "files" {
  for_each      = var.s3_files_map
  bucket        = var.s3_bucket_id
  key           = each.value.s3_key
  content_type  = each.value.content_type
  source        = each.value.source
}

# File: ../Extraction/terraform/modules/s3_uploads/outputs_s3_uploads.tf
# --------------------------------------------------
# 3. Output the object key or anything else needed
output "uploaded_keys" {
  description = "The S3 object key for the uploaded JS file"
  value       = { for k, v in var.s3_files_map : k => v.s3_key }
}

# File: ../Extraction/terraform/modules/s3_uploads/variables_s3_uploads.tf
# --------------------------------------------------
variable "s3_bucket_id" {
  description = "The ID of the S3 bucket"
  type        = string
}

variable "s3_files_map" {
  description = "Mapping of files to be uploaded to S3"
  type = map(object({
    s3_key       = string
    source       = string
    content_type = string
  }))
}



# File: ../Extraction/terraform/modules/secretsmanager/main_secrets_manager.tf
# --------------------------------------------------
resource "aws_secretsmanager_secret_version" "secret_version" {
  secret_id     = var.secrets_id
  secret_string = jsonencode(var.spotify_secrets)
}

# File: ../Extraction/terraform/modules/secretsmanager/outputs_secrets_manager.tf
# --------------------------------------------------
output "secrets_manager_secret_arn" {
  description = "The ARN of the Secrets Manager secret"
  value       = aws_secretsmanager_secret_version.secret_version.arn
}

# File: ../Extraction/terraform/modules/secretsmanager/variables_secrets_manager.tf
# --------------------------------------------------
variable "spotify_secrets" {
  description = "A map containing the Spotify credentials"
  type        = map(string)
}

variable "secrets_id" {
  description = "The ID of the Secrets Manager secret"
  type        = string
}

